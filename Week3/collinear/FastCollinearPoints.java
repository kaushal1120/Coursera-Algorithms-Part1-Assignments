/* ***************************************************************************** *  Name: *  Date: *  Description: **************************************************************************** */import edu.princeton.cs.algs4.In;import edu.princeton.cs.algs4.StdDraw;import edu.princeton.cs.algs4.StdOut;import java.util.ArrayList;import java.util.Arrays;public class FastCollinearPoints {    private LineSegment[] lineSegments;    private int numberOfSegments;    // finds all line segments containing 4 or more points    public FastCollinearPoints(Point[] points) {        if (points == null)            throw new IllegalArgumentException();        int length = points.length;        for (int i = 0; i < length; i++) {            if (points[i] == null)                throw new IllegalArgumentException();        }        for (int i = 0; i < length; i++) {            for (int j = i + 1; j < length; j++) {                if (points[i].compareTo(points[j]) == 0)                    throw new IllegalArgumentException();            }        }        Point[] pointsCopy = Arrays.copyOf(points, points.length);        numberOfSegments = 0;        lineSegments = new LineSegment[length * (length - 1) / 2];        ArrayList<ArrayList<Point>> endPoints = new ArrayList<ArrayList<Point>>();        ArrayList<Double> slopes = new ArrayList<Double>();        // HashMap<Double, ArrayList<Point>> addedSegments = new HashMap<>();        for (int i = 0; i < length - 3; i++) {            Arrays.sort(pointsCopy);            // pointsCopy = Arrays.copyOfRange(pointsCopy, i, length);            Arrays.sort(pointsCopy, pointsCopy[i].slopeOrder());            int count = 1;            int k = 1;            for (; k < length - 1; k++) {                if (Double.compare(pointsCopy[0].slopeTo(pointsCopy[k]),                                   pointsCopy[0].slopeTo(pointsCopy[k + 1]))                        == 0)                    count++;                else {                    if (count >= 3) {                        int j = 0;                        for (; j < slopes.size(); j++) {                            if (Double.compare(slopes.get(j), pointsCopy[0].slopeTo(pointsCopy[k])) == 0)                                break;                        }                        if (j < slopes.size()) {                            int flag = 0;                            for (Point p : endPoints.get(j)) {                                if (p.compareTo(pointsCopy[k]) == 0                                        || p.compareTo(pointsCopy[0]) == 0) {                                    flag = 1;                                    break;                                }                            }                            if (flag == 0) {                                endPoints.get(j).add(pointsCopy[0]);                                endPoints.get(j).add(pointsCopy[k]);                                lineSegments[numberOfSegments++] = new LineSegment(pointsCopy[0],                                                                                   pointsCopy[k]);                            }                        }                        else {                            slopes.add(pointsCopy[0].slopeTo(pointsCopy[k]));                            endPoints.add(new ArrayList<Point>());                            endPoints.get(slopes.size() - 1).add(pointsCopy[0]);                            endPoints.get(slopes.size() - 1).add(pointsCopy[k]);                            lineSegments[numberOfSegments++] = new LineSegment(pointsCopy[0],                                                                               pointsCopy[k]);                        }                    }                    count = 1;                }            }            if (count >= 3) {                int j = 0;                for (; j < slopes.size(); j++) {                    if (Double.compare(slopes.get(j), pointsCopy[0].slopeTo(pointsCopy[k])) == 0)                        break;                }                if (j < slopes.size()) {                    int flag = 0;                    for (Point p : endPoints.get(j)) {                        if (p.compareTo(pointsCopy[k]) == 0                                || p.compareTo(pointsCopy[0]) == 0) {                            flag = 1;                            break;                        }                    }                    if (flag == 0) {                        endPoints.get(j).add(pointsCopy[0]);                        endPoints.get(j).add(pointsCopy[k]);                        lineSegments[numberOfSegments++] = new LineSegment(pointsCopy[0],                                                                           pointsCopy[k]);                    }                }                else {                    slopes.add(pointsCopy[0].slopeTo(pointsCopy[k]));                    endPoints.add(new ArrayList<Point>());                    endPoints.get(slopes.size() - 1).add(pointsCopy[0]);                    endPoints.get(slopes.size() - 1).add(pointsCopy[k]);                    lineSegments[numberOfSegments++] = new LineSegment(pointsCopy[0],                                                                       pointsCopy[k]);                }            }        }    }    public int numberOfSegments() {        return numberOfSegments;    }    // the line segments    public LineSegment[] segments() {        LineSegment[] lineSegmentCopy = new LineSegment[numberOfSegments];        for (int i = 0; i < numberOfSegments; i++)            lineSegmentCopy[i] = lineSegments[i];        return lineSegmentCopy;    }    public static void main(String[] args) {        // read the n points from a file        In in = new In(args[0]);        int n = in.readInt();        Point[] points = new Point[n];        for (int i = 0; i < n; i++) {            int x = in.readInt();            int y = in.readInt();            points[i] = new Point(x, y);        }        // draw the points        StdDraw.enableDoubleBuffering();        StdDraw.setXscale(0, 32768);        StdDraw.setYscale(0, 32768);        for (Point p : points) {            p.draw();        }        StdDraw.show();        // print and draw the line segments        FastCollinearPoints collinear = new FastCollinearPoints(points);        for (LineSegment segment : collinear.segments()) {            StdOut.println(segment);            segment.draw();        }        StdDraw.show();    }}